<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<style>
body {
	margin: 0;
	overflow: hidden;
}

canvas {
	width: 100%;
	height: 100%
}
</style>
</head>
<body>
	<div id='div1'>

		<canvas id='canvas' width=window.innerWidth height=window.innerHeight>

</canvas>

	</div>


	<script src='js/three.js'></script>
	<script src='js/stats.min.js'></script>
	<script src='js/TrackballControls.js'></script>
	<script src='js/OBJLoader.js'></script>
	<script type="text/javascript">
		function onWindowResize() //重置窗口大小
		{

			camera.aspect = window.innerWidth / window.innerHeight; //重置相机比例
			camera.updateProjectionMatrix(); //更新投影矩阵

			renderer.setSize(window.innerWidth, window.innerHeight); //重置渲染的大小

			doucument.getElementById('canvas').width = window.innerWidth;
			doucument.getElementById('canvas').height = window.innerHeight;

		}
		window.addEventListener('resize', onWindowResize, false);
	</script>
	<script type="text/javascript">
		var canvas = document.getElementById('canvas'); //创建一个canvas

		var scene = new THREE.Scene(); //创建一个scene
		var camera = new THREE.PerspectiveCamera(75, window.innerWidth
				/ window.innerHeight, 0.1, 1000); //创建相机
				
		//camera.lookAt(10, 10, 20);??没什么 变化？

		//camera.position.x = 10;
		camera.position.z = 25;
		camera.position.y = 10;

		var renderer = new THREE.WebGLRenderer({
			canvas : document.getElementById('canvas'),
			antialias : true,
			precision : THREE.highp//precision 精度
		
		}); //创建一个渲染器
		renderer.setSize(window.innerWidth, window.innerHeight); //设置渲染器渲染范围
		renderer.setClearColor(0xEEEEEE);

		//添加状态显示模块
		var stats = new Stats(); //定义状态显示器
		stats.setMode(0); //初始默认显示fps

		//设置stats的位置s
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.left = '0px';
		stats.domElement.style.top = '0px';
		document.body.appendChild(stats.domElement); //添加到页面中

		var axes = new THREE.AxisHelper(5);//AxisHelper 用可视化的方法表示三个轴，X为红色，Y为绿色，Z为蓝色
		scene.add(axes);

		//鼠标控制
		var clock = new THREE.Clock();
		var cameraControls = new THREE.TrackballControls(camera,
				renderer.domElement); //定义相机控制器
		cameraControls.target.set(0, 25, 0); //设置中心点坐标

		//添加光线
		var directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
		directionalLight.position.set(1, 1, 1);
		//directionalLight.shadowCameraVisble = true;
		scene.add(directionalLight);

		function changeLight() {
			var position = camera.getWorldDirection();
			directionalLight.position.set(position.x, position.y, position.z);
		}

		//添加网格
		var size = 10;
		var step = 0.5;
		var gridHelper = new THREE.GridHelper(size, step);
		scene.add(gridHelper);
		
		
		//加载模型及贴图		
		function loadModel(){
			//Texture
			var manager = new THREE.LoadingManager();
			
			var onProgress = function ( xhr ) {
				if ( xhr.lengthComputable ) {
					var percentComplete = xhr.loaded / xhr.total * 100;//？？
					console.log( Math.round(percentComplete, 2) + '% downloaded' );
				}
			};

			var onError = function ( xhr ) {
			};
			
			manager.onProgress = function ( item, loaded, total ) {

				console.log( item, loaded, total );

			};

			var texture = new THREE.Texture();

			var loader = new THREE.ImageLoader( manager );
			loader.load( 'models/nakeBody/nakeBody_Packed0_Diffuse.png', function ( image ) {

				texture.image = image;
				texture.needsUpdate = true;

			} );

			//Model
			var loader = new THREE.OBJLoader( manager );
			loader.load( 'models/nakeBody/nakeBody.obj', function ( object ) {

				object.traverse( function ( child ) {

					if ( child instanceof THREE.Mesh ) {

						child.material.map = texture;

					}

				} );
				
				object.children.forEach(function(child) {
					child.geometry.computeFaceNormals();
					child.geometry.computeVertexNormals();
				});
				
				//alert("scale");
				object.scale.set(0.2, 0.2, 0.2);//对加载的模型进行缩放
				
				//object.position.y = -20;//移动模型
				scene.add( object );

			}, onProgress, onError );

		}
		loadModel();

		//制作动画
		function render() {
			requestAnimationFrame(render); //要求定时渲染
			renderer.render(scene, camera); //渲染相机和场景
			stats.update(); //更新

			//相机操控需要
			var delta = clock.getDelta();
			cameraControls.update(delta);
		}
		render();
		
		
	</script>
</body>
</html>